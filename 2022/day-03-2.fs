S" day-03-input.txt" OPEN-BLOCKS

VARIABLE BLOCK-NUMBER   ( CURRENT, NOT NEXT, BLOCK NUMBER. )
VARIABLE BLOCK-START
VARIABLE BLOCK-POS

0 BLOCK-NUMBER !
0 BLOCK DUP BLOCK-START ! BLOCK-POS !

( IF AT THE END OF THE BLOCK, FETCH THE NEXT ONE. )
: ENSURE-BLOCK ( -- )
    BLOCK-POS @ BLOCK-START @ - 1024 =  ( END? )
    IF
	BLOCK-NUMBER @ 1+ DUP           ( NUM+1 NUM+1 )
	BLOCK DUP                       ( NUM+1 START START )
	BLOCK-START ! BLOCK-POS ! BLOCK-NUMBER !
    THEN
;

: PEEK-CHAR ( -- CHAR ) ENSURE-BLOCK BLOCK-POS @ C@ ;
: GET-CHAR ( -- CHAR )
    ENSURE-BLOCK
    BLOCK-POS DUP @ DUP C@ ( @POS POS CHAR )
    SWAP 1+ ROT !
;
: ?NOT-EOF ( -- FLAG ) PEEK-CHAR 26 = 0= ;

( FETCH THE NEXT LINE OF INPUT, INCLUDING NEWLINE, INTO PAD.  )
( COPY CHARACTER-BY-CHARACTER TO HANDLE THE END OF THE BLOCK. )
( ASSUME NOT AT EOF.  RETURNS FALSE FOR BLANK LINES.          )
( THE COUNT NOT INCLUDING THE NEWLINE IS IN THE FIRST         )
( CHARACTER POSITION.                                         )
: GET-NEXT-LINE ( -- FLAG )
    PAD 1+                        ( DST )
    BEGIN
	GET-CHAR DUP 10 = 0=      ( DST CHAR NOT-CR? )
    WHILE
	    OVER C! 1+            ( DST+1 )
    REPEAT
    OVER C!  ( WRITE THE CR AS WELL )
    PAD 1+ - DUP  ( COUNT COUNT )
    PAD C! 0 >  ( STORE THE COUNT, RETURN THE FLAG )
;


( MAP A CHARACTER TO ITS PRIORITY. )
: PRIORITY ( C -- N )
    ( LOWERCASE 'A' IS ASCII 97 AND UPPERCASE 'A' IS 65.  PRIORITY )
    ( OF UPPERCASE 'A' SHOULD BE 27 SO SUBTRACT 38=65-27 FROM      )
    ( UPPERCASE CHARACTERS.                                        )
    DUP 96 >  ( C ?LOWERCASE )
    IF 96 ELSE 38 THEN
    -
;

( BIT VECTOR SETS OF CHARACTERS INDEXED BY PRIORITY. )
( WE NEED 52 BITS -- 7 BYTES.                        )                   
VARIABLE CHARSET
5 ALLOT

VARIABLE OTHER
5 ALLOT

: PRINT-SET ( ADDR -- )
    7 0  ( ADDR 7 0 )
    DO
	DUP I + C@ 8 0  ( ADDR BYTE 8 0 )
	DO
	    DUP 1 AND
	    IF 1 ELSE 0 THEN .
	    2 /
	LOOP
	DROP
    LOOP
    DROP
;

( CLEAR AN ENTIRE BIT VECTOR )
: RESET ( ADDR -- )
    7 0
    DO
	0 OVER I + C!
    LOOP
    DROP
;

( SET BIT POSITION N IN BIT VECTOR ADDR )
: SET ( N ADDR )
    SWAP 8 /MOD  ( ADDR BIT BYTE )
    1 ROT        ( ADDR BYTE 1 BIT )
    DUP 0 >      ( ADDR BYTE 1 BIT BIT>0 )
    IF
	0        ( ADDR BYTE 1 BIT 0 )
	DO
	    DUP +
	LOOP
    ELSE
	DROP
    THEN
    ( ADDR BYTE MASK )
    >R OVER OVER  ( ADDR BYTE ADDR BYTE -- R:MASK )
    + C@ R> OR    ( ADDR BYTE VAL|MASK )
    SWAP ROT      ( VAL|MASK BYTE ADDR )
    + C!
;

( IN-PLACE INTERSECTION OF THE BIT VECTOR AT ADDR1. )
: INTERSECT ( ADDR1 ADDR2 -- )
    SWAP 7 0
    DO
	OVER I + C@  ( ADDR2 ADDR1 BYTE2 )
	OVER I + C@  ( ADDR2 ADDR1 BYTE2 BYTE1 )
	AND          ( ADDR2 ADDR1 BYTE2&BYTE1 )
	OVER I + C!  ( ADDR2 ADDR1 )
    LOOP
    DROP DROP
;

( CONVERT A PACKED STRING IN PAD TO A SET OF PRIORITIES IN ADDR. )
: STRING->SET ( ADDR -- )
    PAD 1+ PAD C@ 0  ( ADDR PAD+1 LEN 0 )
    DO
	I OVER + C@   ( ADDR PAD+1 CI )
	PRIORITY ROT  ( PAD+1 PRI ADDR )
	SWAP 1 - OVER ( PAD+1 ADDR BIT ADDR )
	SET SWAP      ( ADDR PAD+1 )
    LOOP
    DROP DROP
;

( RETURN THE FIRST BIT POSITION SET. )
: FIRST-SET ( ADDR --- )
    0  ( ADDR BYTENUM )
    BEGIN
	OVER OVER + C@ 0=  ( ADDR BYTENUM BYTE=0 )
    WHILE
	    1+
    REPEAT
    ( ADDR BYTENUM )
    DUP ROT + C@ 0 SWAP ( BYTENUM 0 BYTE )
    BEGIN
	DUP 1 AND 0=  ( BYTENUM BITNUM BYTE BYTE&1=0 )
    WHILE
	    2 / SWAP 1+ SWAP ( BYTENUM BITNUM BYTE )
    REPEAT
    DROP
    SWAP 8 * +
;

VARIABLE TOTAL
0 TOTAL !

: RUN ( -- )
    BEGIN
	?NOT-EOF
    WHILE
	    GET-NEXT-LINE DROP  ( DROP THE FLAG, ASSUME IT SUCCEEDS )
	    CHARSET DUP RESET STRING->SET

	    GET-NEXT-LINE DROP
	    OTHER DUP RESET STRING->SET
	    CHARSET OTHER INTERSECT

	    GET-NEXT-LINE DROP
	    OTHER DUP RESET STRING->SET
	    CHARSET OTHER INTERSECT

	    CHARSET FIRST-SET 1+ TOTAL +!
    REPEAT
;

RUN
TOTAL @ . CR
BYE
