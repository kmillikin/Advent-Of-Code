S" day-05-input.txt" OPEN-BLOCKS

VARIABLE BLOCK-NUMBER   ( CURRENT, NOT NEXT, BLOCK NUMBER. )
VARIABLE BLOCK-START
VARIABLE BLOCK-POS

0 BLOCK-NUMBER !
0 BLOCK DUP BLOCK-START ! BLOCK-POS !

( IF AT THE END OF THE BLOCK, FETCH THE NEXT ONE. )
: ENSURE-BLOCK ( -- )
    BLOCK-POS @ BLOCK-START @ - 1024 =  ( END? )
    IF
	BLOCK-NUMBER @ 1+ DUP           ( NUM+1 NUM+1 )
	BLOCK DUP                       ( NUM+1 START START )
	BLOCK-START ! BLOCK-POS ! BLOCK-NUMBER !
    THEN
;

: PEEK-CHAR ( -- CHAR ) ENSURE-BLOCK BLOCK-POS @ C@ ;
: GET-CHAR ( -- CHAR )
    ENSURE-BLOCK
    BLOCK-POS DUP @ DUP C@ ( @POS POS CHAR )
    SWAP 1+ ROT !
;
: ?NOT-EOF ( -- FLAG ) PEEK-CHAR 26 = 0= ;

( FETCH THE NEXT LINE OF INPUT, INCLUDING NEWLINE, INTO PAD.  )
( COPY CHARACTER-BY-CHARACTER TO HANDLE THE END OF THE BLOCK. )
( ASSUME NOT AT EOF.  RETURNS FALSE FOR BLANK LINES.          )
( THE COUNT NOT INCLUDING THE NEWLINE IS IN THE FIRST         )
( CHARACTER POSITION.                                         )
: GET-NEXT-LINE ( -- FLAG )
    PAD 1+                        ( DST )
    BEGIN
	GET-CHAR DUP 10 = 0=      ( DST CHAR NOT-CR? )
    WHILE
	    OVER C! 1+            ( DST+1 )
    REPEAT
    OVER C!  ( WRITE THE CR AS WELL )
    PAD 1+ - DUP  ( COUNT COUNT )
    PAD C! 0 >  ( STORE THE COUNT, RETURN THE FLAG )
;

( PARSE A NUMBER AT ADDR ASSUMING AT LEAST ONE DIGIT. )
( RETURN THE ADDRESS ONE PAST THE LAST DIGIT.         )
: PARSE-NUMBER ( ADDR -- ADDR N )
    DUP C@ 48 -  ( ADDR N )
    SWAP 1+      ( ACC ADDR+1 )
    DUP C@       ( ACC ADDR+1 C )
    ( ASCII DIGITS ARE IN THE RANGE 47..58 EXCLUSIVE. )
    BEGIN
	DUP 47 > OVER 58 < AND
    WHILE
            48 -            ( ADDR+I ACC N )
	    ROT 10 * +      ( ADDR+I 10*ACC+N )
	    SWAP 1+ DUP C@  ( ACC ADDR+I+1 C )
    REPEAT
    DROP SWAP
;

81 CONSTANT SIZE  ( SIZE COUNTING THE LENGTH BYTE. )

( TO RUN THE TEST INPUT, THIS NEEDS TO BE ADJUSTED. )
VARIABLE STACKS
SIZE 9 * ALLOT  ( 9 PACKED STRINGS WITH AT LEAST SIZE-1 CHARACTERS. )

( INITIALIZE THE N'TH STACK FROM A PACKED STRING USING 1 BASED INDEXING. )
: INITIALIZE ( ADDR N -- )
    1- SIZE * STACKS +   ( ADDR STACKS[N-1][0] )
    OVER C@              ( ADDR STACKS[N-1][0] LEN )
    OVER OVER SWAP C!    ( ADDR STACKS[N-1][0] LEN )
    ROT 1+ ROT 1+ ROT 0  ( SRC DST LEN 0 )
    DO
	OVER C@ OVER C!
	1+ SWAP 1+ SWAP
    LOOP
    DROP DROP
;

32 WORD MJCBFRLH 1 INITIALIZE
32 WORD ZCD      2 INITIALIZE
32 WORD HJFCNGW  3 INITIALIZE
32 WORD PJDMTSB  4 INITIALIZE
32 WORD NCDRJ    5 INITIALIZE
32 WORD WLDQPJGZ 6 INITIALIZE
32 WORD PZTFRH   7 INITIALIZE
32 WORD LVMG     8 INITIALIZE
32 WORD CBGPFQRJ 9 INITIALIZE

( PARSE THE LINE AT PAD.  IT HAS THE FIXED FORMAT: )
(   MOVE <NUM> FROM <NUM> TO <NUM>                 )
: PARSE-LINE ( -- NUM SRC DST )
    PAD 6 +  ( SKIP THE SIZE AND 'MOVE ' )
    PARSE-NUMBER
    SWAP 6 +  ( SKIP ' FROM ' )
    PARSE-NUMBER
    SWAP 4 + ( SKIP ' TO ' )
    PARSE-NUMBER
    SWAP DROP
;

: STACK-ADDR ( N -- ADDR ) 1- SIZE * STACKS + ;
: GET-LENGTH ( N -- LEN ) STACK-ADDR C@ ;
: SET-LENGTH ( LEN N -- ) STACK-ADDR C! ;

: POP ( N -- C )
    STACK-ADDR DUP C@  ( ADDR LEN )
    SWAP OVER 1- OVER  ( LEN ADDR LEN-1 ADDR )
    C! + C@
;

: PUSH ( C N -- )
    STACK-ADDR DUP C@  ( C ADDR LEN )
    1+ SWAP OVER OVER  ( C LEN+1 ADDR LEN+1 ADDR )
    C! + C!
;

: PERFORM-MOVE ( NUM SRC DST -- )
    ( SRC AND DST STACKS USE 1-BASED INDEXING.   )
    ( FETCH THE ADDRESS OF THE TOP OF THE STACK. )
    ( ADDRESS CONTAINS THE TOP ELEMENT.          )
    ROT 0 ( SRC DST NUM 0 )
    DO
	OVER POP OVER PUSH ( SRC DST C )
    LOOP
    DROP DROP
;

( READ THE TOP OF EACH STACK INTO PAD.  LENGTH IS THE NUMBER OF STACKS. )
: WRITE-TOP ( -- )
    PAD 9 0
    DO
	I SIZE * STACKS + DUP C@ ( PAD ADDR NUM )
	+ C@ OVER C! 1+          ( PAD+1 )
    LOOP
    DROP
    PAD 9 TYPE CR
;

: RUN ( -- )
    BEGIN
	?NOT-EOF
    WHILE
	    GET-NEXT-LINE DROP
	    PARSE-LINE
	    PERFORM-MOVE
    REPEAT
;

RUN
WRITE-TOP
BYE
