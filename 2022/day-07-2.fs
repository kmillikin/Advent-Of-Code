S" day-07-input.txt" OPEN-BLOCKS

VARIABLE BLOCK-NUMBER   ( CURRENT, NOT NEXT, BLOCK NUMBER. )
VARIABLE BLOCK-START
VARIABLE BLOCK-POS

0 BLOCK-NUMBER !
0 BLOCK DUP BLOCK-START ! BLOCK-POS !

( IF AT THE END OF THE BLOCK, FETCH THE NEXT ONE. )
: ENSURE-BLOCK ( -- )
    BLOCK-POS @ BLOCK-START @ - 1024 =  ( END? )
    IF
	BLOCK-NUMBER @ 1+ DUP           ( NUM+1 NUM+1 )
	BLOCK DUP                       ( NUM+1 START START )
	BLOCK-START ! BLOCK-POS ! BLOCK-NUMBER !
    THEN
;

: PEEK-CHAR ( -- CHAR ) ENSURE-BLOCK BLOCK-POS @ C@ ;
: GET-CHAR ( -- CHAR )
    ENSURE-BLOCK
    BLOCK-POS DUP @ DUP C@ ( @POS POS CHAR )
    SWAP 1+ ROT !
;
: NOT-EOF? ( -- FLAG ) PEEK-CHAR 26 = 0= ;

( FETCH THE NEXT LINE OF INPUT, INCLUDING NEWLINE, INTO PAD.  )
( COPY CHARACTER-BY-CHARACTER TO HANDLE THE END OF THE BLOCK. )
( ASSUME NOT AT EOF.  RETURNS FALSE FOR BLANK LINES.          )
( THE COUNT NOT INCLUDING THE NEWLINE IS IN THE FIRST         )
( CHARACTER POSITION.                                         )
: GET-NEXT-LINE ( -- FLAG )
    PAD 1+                        ( DST )
    BEGIN
	GET-CHAR DUP 10 = 0=      ( DST CHAR NOT-CR? )
    WHILE
	    OVER C! 1+            ( DST+1 )
    REPEAT
    OVER C!  ( WRITE THE CR AS WELL )
    PAD 1+ - DUP  ( COUNT COUNT )
    PAD C! 0 >  ( STORE THE COUNT, RETURN THE FLAG )
;

( PARSE A NUMBER AT ADDR ASSUMING AT LEAST ONE DIGIT. )
( RETURN THE ADDRESS ONE PAST THE LAST DIGIT.         )
: PARSE-NUMBER ( ADDR -- ADDR N )
    DUP C@ 48 -  ( ADDR N )
    SWAP 1+      ( ACC ADDR+1 )
    DUP C@       ( ACC ADDR+1 C )
    ( ASCII DIGITS ARE IN THE RANGE 47..58 EXCLUSIVE. )
    BEGIN
	DUP 47 > OVER 58 < AND
    WHILE
            48 -            ( ADDR+I ACC N )
	    ROT 10 * +      ( ADDR+I 10*ACC+N )
	    SWAP 1+ DUP C@  ( ACC ADDR+I+1 C )
    REPEAT
    DROP SWAP
;

( COMPARE A PAIR OF PACKED STRINGS. )
: STRING= ( ADDR1 ADDR2 -- FLAG )
    OVER C@ OVER C@ = 0= ( ADDR1 ADDR2 LEN1!=LEN2 )
    IF
	DROP DROP 0
    ELSE
	DUP C@ 0 ( ADDR1 ADDR2 LEN 0 )
	DO
	    OVER I + 1+ C@ ( ADDR1 ADDR2 ADDR1[I+1] )
	    OVER I + 1+ C@ ( ADDR1 ADDR2 ADDR1[I+1] ADDR2[I+1] )
	    = 0=
	    IF
		DROP 0 LEAVE
	    THEN
	LOOP
	( ADDR1 FLAG )
	0= IF DROP 0 ELSE DROP -1 THEN
    THEN
;

( COPY A PACKED STRING INCLUDING LENGTH. )
: COPY-STRING ( DST SRC -- )
    DUP C@ 1+ 0  ( DST SRC LEN+1 0 )
    DO
	OVER OVER    ( DST SRC DST SRC )
	I + C@       ( DST SRC DST CHAR )
	SWAP I + C!  ( DST SRC )
    LOOP
    DROP DROP
;

VARIABLE ROOT-DIR     ( HOLDS THE ADDRESS OF THE TOP DIRECTORY)
VARIABLE CURRENT-DIR  ( ADDRESS OF THE CURRENT DIRECTORY )
VARIABLE DIR-COUNT
0 DIR-COUNT !

( A DIRECTORY HAS THE STRUCTURE:           )
( - PARENT ADDRESS, -1 FOR TOP             )
( - SIZE INCLUDING SUBDIRECTORIES          )
( - NUMBER OF CHILDREN                     )
( - ARRAY OF CHILDREN ENTRIES              )
: DIR-PARENT-ADDR ( ADDR -- ADDR ) ;
: DIR-SIZE-ADDR ( ADDR -- ADDR ) 1 CELLS + ;
: DIR-CHILD-COUNT-ADDR ( ADDR -- ADDR ) 2 CELLS + ;
: DIR-CHILDREN-ADDR ( ADDR -- ADDR ) 3 CELLS + ;

: INIT-DIR ( PARENT -- ADDR )
    1 DIR-COUNT +!
    HERE 3 CELLS ALLOT  ( PARENT ADDR )
    SWAP OVER DIR-PARENT-ADDR !    ( PARENT )
    0 OVER DIR-SIZE-ADDR !         ( INITIAL SIZE )
    0 OVER DIR-CHILD-COUNT-ADDR !  ( INITIAL NUMBER OF CHILDREN )
;

( CHILDREN ENTRIES ARE DIRECTORY OR FILE ENTRIES. )
( ALL ENTRIES HAVE THE STRUCTURE:                 )
( - TAG BYTE, 0=DIRECTORY, 1=FILE                 )

( DIRECTORY ENTRIES HAVE THE STRUCTURE: )
( - TAG BYTE 0                          )
( - ADDRESS OF DIRECTORY                )
( - NAME [PACKED STRING]                )
: DIR-ENTRY? ( ADDR -- FLAG ) C@ 0= ;
: DIR-ENTRY-ADDR-ADDR ( ADDR -- ADDR ) 1+ ;

( FILE ENTRIES HAVE THE NAME AT THE SAME OFFSET. )
: ENTRY-NAME-ADDR ( ADDR -- ADDR ) 1+ 1 CELLS + ;

: INIT-DIR-ENTRY ( NAME -- ADDR )
    ( INCREMENT THE ENCLOSING DIRECTORY'S CHILD COUNT. )
    1 CURRENT-DIR @ DIR-CHILD-COUNT-ADDR +!

    HERE
    OVER C@ 1+    ( NAME ADDR NAME-LEN )
    1+ 1 CELLS +  ( NAME ADDR ENTRY-SIZE )
    ALLOT         ( NAME ADDR )
    0 OVER C!                      ( SET THE TAG. )
    -1 OVER DIR-ENTRY-ADDR-ADDR !  ( DIRECTORY NOT YET ALLOCATED. )

    ( COPY THE NAME STRING. )
    DUP ENTRY-NAME-ADDR ROT  ( ADDR NAME-ADDR NAME )
    COPY-STRING
;

( FILE ENTRIES HAVE THE STRUCTURE: )
( - TAG BYTE 1                     )
( - SIZE                           )
( - NAME [PACKED STRING]           )
: FILE-ENTRY? ( ADDR -- FLAG ) C@ 1 = ;
: FILE-ENTRY-SIZE-ADDR ( ADDR -- ADDR) 1+ ;

: INIT-FILE-ENTRY ( SIZE NAME -- ADDR )
    ( INCREMENT THE ENCLOSING DIRECTORY'S CHILD COUNT. )
    1 CURRENT-DIR @ DIR-CHILD-COUNT-ADDR +!

    HERE
    OVER C@ 1+    ( SIZE NAME ADDR NAME-LEN )
    1+ 1 CELLS +  ( SIZE NAME ADDR ENTRY-SIZE )
    ALLOT         ( SIZE NAME ADDR )
    1 OVER C!  ( SET THE TAG. )

    ( COPY THE NAME STRING. )
    DUP ENTRY-NAME-ADDR ROT ( SIZE ADDR NAME-ADDR NAME )
    COPY-STRING

    OVER OVER FILE-ENTRY-SIZE-ADDR !  ( SET THE SIZE. )

    ( NOW UPDATE THE SIZE OF ALL DIRECTORIES FROM CURRENT TO ROOT. )
    SWAP           ( ADDR SIZE )
    CURRENT-DIR @  ( ADDR SIZE DIR )
    BEGIN
	DUP -1 = 0=
    WHILE
	    OVER OVER          ( ADDR SIZE DIR SIZE DIR )
	    DIR-SIZE-ADDR +!   ( ADDR SIZE DIR )
	    DIR-PARENT-ADDR @  ( ADDR SIZE PARENT )
    REPEAT
    DROP DROP
;

: NEXT-ENTRY ( ADDR -- ADDR ) ENTRY-NAME-ADDR DUP C@ ( NAME LEN ) + 1+ ;

( SET ROOT AS CURRENT DIR. )
: CD-TOP ( -- ) ROOT-DIR @ CURRENT-DIR ! ;

( SET CURRENT PARENT AS CURRENT DIR. )
: CD-UP ( -- )
    CURRENT-DIR @ DIR-PARENT-ADDR @  ( PARENT )
    CURRENT-DIR !
;

( GIVEN ADDRESS OF PACKED STRING, FIND THE MATCHING DIRECTORY ENTRY. )
( ALLOCATE AND INITIALIZE A DIRECTORY IF NECESSARY.                  )
( SET THE CURRENT DIRECTORY.                                         )
: CD-DOWN ( NAME -- )
    CURRENT-DIR @ DIR-CHILDREN-ADDR SWAP ( FIRST-ENTRY NAME )
    BEGIN
	( ASSUME WE WILL FIND THE STRING. )
	( SKIP FILES AND DIRECTORIES WITH THE WRONG NAME. )
	OVER FILE-ENTRY? DUP 0= ( ENTRY NAME FILE? NOT-FILE? )
	IF
	    DROP OVER ENTRY-NAME-ADDR OVER STRING= 0= ( ENTRY NAME NOT-FOUND )
	THEN
    WHILE
	    SWAP NEXT-ENTRY SWAP  ( NEXT-ENTRY NAME )
    REPEAT
    DROP
    DUP DIR-ENTRY-ADDR-ADDR @  ( ENTRY DIR-ADDR )
    DUP -1 =
    IF
	DROP CURRENT-DIR @ INIT-DIR  ( ENTRY NEW-DIR )
	OVER OVER SWAP               ( ENTRY NEW-DIR NEW-DIR ENTRY )
	DIR-ENTRY-ADDR-ADDR !        ( ENTRY NEW-DIR )
    THEN
    ( ENTRY DIR-ADDR )
    CURRENT-DIR !
    DROP
;


( NOW WE NEED TO LOOP OVER ALL DIRS TO FIND THE RESULT. )
VARIABLE TARGET
0 TARGET !

VARIABLE BEST-SIZE
70000001 BEST-SIZE !

: COMPUTE-RESULT ( -- )
    70000000 ROOT-DIR @ DIR-SIZE-ADDR @ -  ( FREE )
    ( NEED THE SMALLEST DIRECTORY SUCH THAT SIZE >= 30000000-FREE. )
    30000000 SWAP - TARGET !
    ROOT-DIR @ DIR-COUNT @ 0  ( ADDR COUNT 0 )
    DO
	DUP DIR-SIZE-ADDR @ TARGET @ OVER < ( ADDR SIZE TARGET<SIZE )
	IF
	    BEST-SIZE @ MIN BEST-SIZE !
	ELSE
	    DROP
	THEN
	DUP DIR-CHILDREN-ADDR SWAP DIR-CHILD-COUNT-ADDR @ 0
	( FIRST-CHILD CHILD-COUNT 0 )
	DO
	    NEXT-ENTRY
	LOOP
    LOOP
    DROP
;


: RUN ( -- )
    -1 INIT-DIR     ( ADDR )
    DUP ROOT-DIR !  ( SET AS ROOT )
    CURRENT-DIR !   ( SET AS CURRENT )
    BEGIN
	NOT-EOF?
    WHILE
	    GET-NEXT-LINE DROP
	    ( A LITTLE COMMAND PARSER. )
	    PAD 1+ C@ 36 =  ( IS IT "$"? )
	    IF
		PAD 3 + C@ 99 =  ( IS IT "$ C"? )
		IF
		    PAD 6 + C@ DUP 47 =  ( IS IT "$ CD /"? )
		    IF
			DROP CD-TOP
		    ELSE
			46 =  ( IS IT "$ CD .."? )
			IF
			    CD-UP
			ELSE
			    ( "$ CD <NAME>".  WRITE THE NAME LENGTH BYTE. )
			    PAD 5 + DUP  ( PAD+5 PAD+5 )
			    PAD C@ 5 -   ( PAD+5 PAD+5 LEN-5 )
			    SWAP C!
			    CD-DOWN
			THEN
		    THEN
		ELSE
		    ( "$ LS".  JUST SKIP IT AND READ THE ENTRIES. )
		THEN
	    ELSE
		( AN ENTRY. )
		PAD 1+ C@ 100 =  ( IS IT "D"? )
		IF
		    ( "DIR <NAME>".  WRITE THE NAME LENGTH BYTE. )
		    PAD 4 + DUP  ( PAD+4 PAD+4 )
		    PAD C@ 4 -   ( PAD+4 PAD+4 LEN-4 )
		    SWAP C!
		    INIT-DIR-ENTRY DROP
		ELSE
		    ( "<LENGTH> <NAME>".  PARSE THE LENGTH. )
		    PAD 1+ PARSE-NUMBER  ( END-ADDR LENGTH )
		    ( THE ADDRESS IS THE ADDRESS OF THE SPACE BETWEEN LENGTH )
		    ( AND NAME.  WRITE THE NAME LENGTH THERE.                )
		    SWAP DUP PAD -  ( LENGTH NAME OFFSET )
		    PAD C@ SWAP -   ( LENGTH NAME NAME-LEN )
		    OVER C!         ( LENGTH NAME )
		    INIT-FILE-ENTRY DROP
		THEN
	    THEN
    REPEAT
;

RUN
COMPUTE-RESULT
BEST-SIZE @ . CR
BYE
