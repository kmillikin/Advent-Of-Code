S" day-06-input.txt" OPEN-BLOCKS

VARIABLE BLOCK-NUMBER   ( CURRENT, NOT NEXT, BLOCK NUMBER. )
VARIABLE BLOCK-START
VARIABLE BLOCK-POS

0 BLOCK-NUMBER !
0 BLOCK DUP BLOCK-START ! BLOCK-POS !

( IF AT THE END OF THE BLOCK, FETCH THE NEXT ONE. )
: ENSURE-BLOCK ( -- )
    BLOCK-POS @ BLOCK-START @ - 1024 =  ( END? )
    IF
	BLOCK-NUMBER @ 1+ DUP           ( NUM+1 NUM+1 )
	BLOCK DUP                       ( NUM+1 START START )
	BLOCK-START ! BLOCK-POS ! BLOCK-NUMBER !
    THEN
;

: PEEK-CHAR ( -- CHAR ) ENSURE-BLOCK BLOCK-POS @ C@ ;
: GET-CHAR ( -- CHAR )
    ENSURE-BLOCK
    BLOCK-POS DUP @ DUP C@ ( @POS POS CHAR )
    SWAP 1+ ROT !
;
: NOT-EOF? ( -- FLAG ) PEEK-CHAR 26 = 0= ;


( OPERATE DIRECTLY ON THE BLOCK INPUT RATHER THAN LINE-BY LINE LIKE IN )
( PREVIOUS DAYS.  THE INPUT IS A SINGLE LINE, AND IT MIGHT BE TOO LONG )
( FOR PAD.                                                             )

14 CONSTANT SIZE

VARIABLE QUEUE
SIZE ALLOT

VARIABLE HEAD
0 HEAD !

( READ THE FIRST FOUR CHARACTERS INTO THE QUEUE. )
: START ( -- )
    QUEUE SIZE 0
    DO
	DUP I +           ( QUEUE &QUEUE[I] )
	GET-CHAR SWAP C!  ( QUEUE )
    LOOP
    DROP
;

: NOT-MARKER ( -- FLAG )
    0 SIZE 1- 0  ( FALSE 4 0 )
    DO
	SIZE I 1+    ( FLAG 4 I+1 )
	DO
	    QUEUE I + C@
	    QUEUE J + C@
	    = OR
	LOOP
    LOOP
;

( READ AND ENQUEUE THE NEXT CHARACTER. )
: ENQUEUE-NEXT ( -- )
    GET-CHAR QUEUE HEAD @ +  ( CHAR &QUEUE[HEAD] )
    C! HEAD @ 1+ SIZE MOD HEAD !
;

: RUN ( -- )
    START SIZE  ( COUNT )
    BEGIN
	NOT-MARKER
    WHILE
	    1+ ENQUEUE-NEXT
    REPEAT
;

RUN
. CR
BYE